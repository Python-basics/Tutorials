Python 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 22:39:24) [MSC v.1916 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license()" for more information.
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> Pos_Neg(4)
Positive
Negative
Positive
Negative
Zero
Positive
Negative
Positive
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
-5
2
-4
0
6
-10
3
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Positive
Negative
Positive
Negative
Zero
Positive
Negative
Positive
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
01234
01234
01234
01234
01234
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python36-32\triangle.py
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
0
1
2
3
4
5
6
7
8
9
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
2
3
4
5
6
7
8
9
10
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
01
012
0123
01234
012345
0123456
01234567
012345678
0123456789
012345678910
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
0
01
012
0123
01234
012345
0123456
01234567
012345678
0123456789
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
01
012
0123
01234
012345
0123456
01234567
012345678
0123456789
012345678910
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py

1
12
123
1234
12345
123456
1234567
12345678
123456789
>>> row
10
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'col', 'row']
>>> col
9
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
1234567891011
123456789101112
12345678910111213
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
{}.format(col)
{}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
{}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col){}.format(col)
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
1234567891011
123456789101112
12345678910111213
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
  1
  1  2
  1  2  3
  1  2  3  4
  1  2  3  4  5
  1  2  3  4  5  6
  1  2  3  4  5  6  7
  1  2  3  4  5  6  7  8
  1  2  3  4  5  6  7  8  9
  1  2  3  4  5  6  7  8  9 10
  1  2  3  4  5  6  7  8  9 10 11
  1  2  3  4  5  6  7  8  9 10 11 12
  1  2  3  4  5  6  7  8  9 10 11 12 13
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
 1
 1 2
 1 2 3
 1 2 3 4
 1 2 3 4 5
 1 2 3 4 5 6
 1 2 3 4 5 6 7
 1 2 3 4 5 6 7 8
 1 2 3 4 5 6 7 8 9
 1 2 3 4 5 6 7 8 910
 1 2 3 4 5 6 7 8 91011
 1 2 3 4 5 6 7 8 9101112
 1 2 3 4 5 6 7 8 910111213
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
  1
  1  2
  1  2  3
  1  2  3  4
  1  2  3  4  5
  1  2  3  4  5  6
  1  2  3  4  5  6  7
  1  2  3  4  5  6  7  8
  1  2  3  4  5  6  7  8  9
  1  2  3  4  5  6  7  8  9 10
  1  2  3  4  5  6  7  8  9 10 11
  1  2  3  4  5  6  7  8  9 10 11 12
  1  2  3  4  5  6  7  8  9 10 11 12 13
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter name: Sam
Hello Sam
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter name: Sam
Hello Sam nice to meet you.
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter name: Sam
Hello Sam nice to meet you.
>>> i = 0
>>> i = i + 1
>>> i = 0
>>> i
0
>>> i = i + 1
>>> i
1
>>> i += 1
>>> i
2
>>> i -= 1
>>> i
1
>>> number = input("Enter a number: ")
Enter a number: 5
>>> i
1
>>> i
1
>>> i
1
>>> i
1
>>> i -= 1
>>> i -= 1
>>> i
-1
>>> number
'5'
>>> '5'
'5'
>>> type(number)
<class 'str'>
>>> number + 1
Traceback (most recent call last):
  File "<pyshell#25>", line 1, in <module>
    number + 1
TypeError: can only concatenate str (not "int") to str
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 6
6
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
<class 'str'>
>>> 1 + number
Traceback (most recent call last):
  File "<pyshell#26>", line 1, in <module>
    1 + number
TypeError: unsupported operand type(s) for +: 'int' and 'str'
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
<class 'int'>
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
<class 'int'>
>>> help()

Welcome to Python 3.8's help utility!

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at https://docs.python.org/3.8/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, symbols, or topics, type
"modules", "keywords", "symbols", or "topics".  Each module also comes
with a one-line summary of what it does; to list the modules whose name
or summary contain a given string such as "spam", type "modules spam".

help> keywords

Here is a list of the Python keywords.  Enter any keyword to get more help.

False               class               from                or
None                continue            global              pass
True                def                 if                  raise
and                 del                 import              return
as                  elif                in                  try
assert              else                is                  while
async               except              lambda              with
await               finally             nonlocal            yield
break               for                 not                 

help> while
The "while" statement
*********************

The "while" statement is used for repeated execution as long as an
expression is true:

   while_stmt ::= "while" expression ":" suite
                  ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time
it is tested) the suite of the "else" clause, if present, is executed
and the loop terminates.

A "break" statement executed in the first suite terminates the loop
without executing the "else" clause’s suite.  A "continue" statement
executed in the first suite skips the rest of the suite and goes back
to testing the expression.

Related help topics: break, continue, if, TRUTHVALUE

help> 

You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.
>>> 
>>> while True:
	print("HI")

	
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI
HI

================================ RESTART: Shell ================================
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
4
3
2
1
0
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
5
4
3
2
1
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
ready
5
4
3
2
1
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
ready
5
4
3
2
1
0
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
ready
5
Blastoff!!!!!!!
4
Blastoff!!!!!!!
3
Blastoff!!!!!!!
2
Blastoff!!!!!!!
1
Blastoff!!!!!!!
0
Blastoff!!!!!!!
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
Enter Number: 5
ready
5
4
3
2
1
0
Blastoff!!!!!!!
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> numbers
[1, -5, 2, -4, 0, 6, -10, 3]
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'numbers']
>>> dir(numbers)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
1
-5
2
-4
0
6
-10
3
>>> help(numbers.append)
Help on built-in function append:

append(object, /) method of builtins.list instance
    Append object to the end of the list.

>>> pos
[]
>>> pos.append(4)
>>> pos
[4]
>>> neg.append(-3)
>>> neg
[-3]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> po
Traceback (most recent call last):
  File "<pyshell#41>", line 1, in <module>
    po
NameError: name 'po' is not defined
>>> pos
[1, 2, 6, 3]
>>> neg
[-5, -4, 0, -10]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> numbers
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> pos
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> dir(numbers)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> list_numbers
[[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
>>> for i in list_numbers:
	print(i)

	
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
>>> import random
>>> help()

Welcome to Python 3.8's help utility!

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at https://docs.python.org/3.8/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, symbols, or topics, type
"modules", "keywords", "symbols", or "topics".  Each module also comes
with a one-line summary of what it does; to list the modules whose name
or summary contain a given string such as "spam", type "modules spam".

help> keywords

Here is a list of the Python keywords.  Enter any keyword to get more help.

False               class               from                or
None                continue            global              pass
True                def                 if                  raise
and                 del                 import              return
as                  elif                in                  try
assert              else                is                  while
async               except              lambda              with
await               finally             nonlocal            yield
break               for                 not                 

help> import
The "import" statement
**********************

   import_stmt     ::= "import" module ["as" identifier] ("," module ["as" identifier])*
                   | "from" relative_module "import" identifier ["as" identifier]
                   ("," identifier ["as" identifier])*
                   | "from" relative_module "import" "(" identifier ["as" identifier]
                   ("," identifier ["as" identifier])* [","] ")"
                   | "from" module "import" "*"
   module          ::= (identifier ".")* identifier
   relative_module ::= "."* module | "."+

The basic import statement (no "from" clause) is executed in two
steps:

1. find a module, loading and initializing it if necessary

2. define a name or names in the local namespace for the scope
   where the "import" statement occurs.

When the statement contains multiple clauses (separated by commas) the
two steps are carried out separately for each clause, just as though
the clauses had been separated out into individual import statements.

The details of the first step, finding and loading modules are
described in greater detail in the section on the import system, which
also describes the various types of packages and modules that can be
imported, as well as all the hooks that can be used to customize the
import system. Note that failures in this step may indicate either
that the module could not be located, *or* that an error occurred
while initializing the module, which includes execution of the
module’s code.

If the requested module is retrieved successfully, it will be made
available in the local namespace in one of three ways:

* If the module name is followed by "as", then the name following
  "as" is bound directly to the imported module.

* If no other name is specified, and the module being imported is a
  top level module, the module’s name is bound in the local namespace
  as a reference to the imported module

* If the module being imported is *not* a top level module, then the
  name of the top level package that contains the module is bound in
  the local namespace as a reference to the top level package. The
  imported module must be accessed using its full qualified name
  rather than directly

The "from" form uses a slightly more complex process:

1. find the module specified in the "from" clause, loading and
   initializing it if necessary;

2. for each of the identifiers specified in the "import" clauses:

   1. check if the imported module has an attribute by that name

   2. if not, attempt to import a submodule with that name and then
      check the imported module again for that attribute

   3. if the attribute is not found, "ImportError" is raised.

   4. otherwise, a reference to that value is stored in the local
      namespace, using the name in the "as" clause if it is present,
      otherwise using the attribute name

Examples:

   import foo                 # foo imported and bound locally
   import foo.bar.baz         # foo.bar.baz imported, foo bound locally
   import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb
   from foo.bar import baz    # foo.bar.baz imported and bound as baz
   from foo import attr       # foo imported and foo.attr bound as attr

If the list of identifiers is replaced by a star ("'*'"), all public
names defined in the module are bound in the local namespace for the
scope where the "import" statement occurs.

The *public names* defined by a module are determined by checking the
module’s namespace for a variable named "__all__"; if defined, it must
be a sequence of strings which are names defined or imported by that
module.  The names given in "__all__" are all considered public and
are required to exist.  If "__all__" is not defined, the set of public
names includes all names found in the module’s namespace which do not
begin with an underscore character ("'_'").  "__all__" should contain
the entire public API. It is intended to avoid accidentally exporting
items that are not part of the API (such as library modules which were
imported and used within the module).

The wild card form of import — "from module import *" — is only
allowed at the module level.  Attempting to use it in class or
function definitions will raise a "SyntaxError".

When specifying what module to import you do not have to specify the
absolute name of the module. When a module or package is contained
within another package it is possible to make a relative import within
the same top package without having to mention the package name. By
using leading dots in the specified module or package after "from" you
can specify how high to traverse up the current package hierarchy
without specifying exact names. One leading dot means the current
package where the module making the import exists. Two dots means up
one package level. Three dots is up two levels, etc. So if you execute
"from . import mod" from a module in the "pkg" package then you will
end up importing "pkg.mod". If you execute "from ..subpkg2 import mod"
from within "pkg.subpkg1" you will import "pkg.subpkg2.mod". The
specification for relative imports is contained in the Package
Relative Imports section.

"importlib.import_module()" is provided to support applications that
determine dynamically the modules to be loaded.

Raises an auditing event "import" with arguments "module", "filename",
"sys.path", "sys.meta_path", "sys.path_hooks".


Future statements
=================

A *future statement* is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python where the feature
becomes standard.

The future statement is intended to ease migration to future versions
of Python that introduce incompatible changes to the language.  It
allows use of the new features on a per-module basis before the
release in which the feature becomes standard.

   future_stmt ::= "from" "__future__" "import" feature ["as" identifier]
                   ("," feature ["as" identifier])*
                   | "from" "__future__" "import" "(" feature ["as" identifier]
                   ("," feature ["as" identifier])* [","] ")"
   feature     ::= identifier

A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

* the module docstring (if any),

* comments,

* blank lines, and

* other future statements.

The only feature in Python 3.7 that requires using the future
statement is "annotations".

All historical features enabled by the future statement are still
recognized by Python 3.  The list includes "absolute_import",
"division", "generators", "generator_stop", "unicode_literals",
"print_function", "nested_scopes" and "with_statement".  They are all
redundant because they are always enabled, and only kept for backwards
compatibility.

A future statement is recognized and treated specially at compile
time: Changes to the semantics of core constructs are often
implemented by generating different code.  It may even be the case
that a new feature introduces new incompatible syntax (such as a new
reserved word), in which case the compiler may need to parse the
module differently.  Such decisions cannot be pushed off until
runtime.

For any given release, the compiler knows which feature names have
been defined, and raises a compile-time error if a future statement
contains a feature not known to it.

The direct runtime semantics are the same as for any import statement:
there is a standard module "__future__", described later, and it will
be imported in the usual way at the time the future statement is
executed.

The interesting runtime semantics depend on the specific feature
enabled by the future statement.

Note that there is nothing special about the statement:

   import __future__ [as name]

That is not a future statement; it’s an ordinary import statement with
no special semantics or syntax restrictions.

Code compiled by calls to the built-in functions "exec()" and
"compile()" that occur in a module "M" containing a future statement
will, by default, use the new syntax or semantics associated with the
future statement.  This can be controlled by optional arguments to
"compile()" — see the documentation of that function for details.

A future statement typed at an interactive interpreter prompt will
take effect for the rest of the interpreter session.  If an
interpreter is started with the "-i" option, is passed a script name
to execute, and the script includes a future statement, it will be in
effect in the interactive session started after the script is
executed.

See also:

  **PEP 236** - Back to the __future__
     The original proposal for the __future__ mechanism.

Related help topics: MODULES

help> 

You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.
>>> 
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'i', 'list_numbers', 'numbers', 'random']
>>> dir(random)
['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_Sequence', '_Set', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_accumulate', '_acos', '_bisect', '_ceil', '_cos', '_e', '_exp', '_inst', '_log', '_os', '_pi', '_random', '_repeat', '_sha512', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn', 'betavariate', 'choice', 'choices', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate']
>>> help(random.randint)
Help on method randint in module random:

randint(a, b) method of random.Random instance
    Return random integer in range [a, b], including both end points.

>>> for i in range(10):
	print(random.randint(1,5))

	
1
2
5
1
1
3
1
2
2
5
>>> help(random.shuffle)
Help on method shuffle in module random:

shuffle(x, random=None) method of random.Random instance
    Shuffle list x in place, and return None.
    
    Optional argument random is a 0-argument function returning a
    random float in [0.0, 1.0); if it is the default None, the
    standard random.random will be used.

>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> numbers
[1, -5, 2, -4, 0, 6, -10, 3]
>>> number
[5, 2, 1, 2, 1, 1, 5, 5, 2, 2]
>>> len(number)
10
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> numbers
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
>>> dir(numbers)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> numbers
[8, 5, 2, 25, 7, 1, 11, 17, 15, 13, 23, 9, 19, 21, 22, 3, 16, 24, 12, 14, 4, 10, 20, 6, 18]
>>> help(numbers.pop)
Help on built-in function pop:

pop(index=-1, /) method of builtins.list instance
    Remove and return item at index (default last).
    
    Raises IndexError if list is empty or index is out of range.

>>> numbers
[8, 5, 2, 25, 7, 1, 11, 17, 15, 13, 23, 9, 19, 21, 22, 3, 16, 24, 12, 14, 4, 10, 20, 6, 18]
>>> numbersnumbers
Traceback (most recent call last):
  File "<pyshell#69>", line 1, in <module>
    numbersnumbers
NameError: name 'numbersnumbers' is not defined
>>> numbers[-1]
18
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> hou
Traceback (most recent call last):
  File "<pyshell#71>", line 1, in <module>
    hou
NameError: name 'hou' is not defined
>>> horses
[[], [], [], [], []]
>>> len(horses)
5
>>> dir(random)
['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_Sequence', '_Set', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_accumulate', '_acos', '_bisect', '_ceil', '_cos', '_e', '_exp', '_inst', '_log', '_os', '_pi', '_random', '_repeat', '_sha512', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn', 'betavariate', 'choice', 'choices', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate']
>>> help(random.choice)
Help on method choice in module random:

choice(seq) method of random.Random instance
    Choose a random element from a non-empty sequence.

>>> for i in horses:
	print(i)

	
[]
[]
[]
[]
[]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[]
[]
[]
[]
[]
>>> help(list.pop)
Help on method_descriptor:

pop(self, index=-1, /)
    Remove and return item at index (default last).
    
    Raises IndexError if list is empty or index is out of range.

>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
8
5
2
25
7
1
11
17
15
13
23
9
19
21
22
3
16
24
12
14
4
10
20
6
18
>>> help(shuffled.pop)
Help on built-in function pop:

pop(index=-1, /) method of builtins.list instance
    Remove and return item at index (default last).
    
    Raises IndexError if list is empty or index is out of range.

>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> horses
[[0], [1], [2], [3], [4]]
>>> 
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> horses
[[2], [0], [4], [1], [3]]
>>> horses[0]
[2]
>>> horses[3]
[1]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> horses
[[2, 18, 14, 22, 13, 7], [0, 6, 12, 21, 15, 25], [4, 20, 24, 19, 17, 2], [1, 10, 16, 9, 11, 5], [3, 4, 3, 23, 1, 8]]
>>> for race in horses;
SyntaxError: invalid syntax
>>> for race in horses:
	print(race)

	
[2, 18, 14, 22, 13, 7]
[0, 6, 12, 21, 15, 25]
[4, 20, 24, 19, 17, 2]
[1, 10, 16, 9, 11, 5]
[3, 4, 3, 23, 1, 8]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> for race in horses:
	print(race)

	
[18, 14, 22, 13, 7]
[6, 12, 21, 15, 25]
[20, 24, 19, 17, 2]
[10, 16, 9, 11, 5]
[4, 3, 23, 1, 8]
>>> dir(horses)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> help(horses)

>>> help(horses.sort)
Help on built-in function sort:

sort(*, key=None, reverse=False) method of builtins.list instance
    Sort the list in ascending order and return None.
    
    The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
    order of two equal elements is maintained).
    
    If a key function is given, apply it once to each list item and sort them,
    ascending or descending, according to their function values.
    
    The reverse flag can be set to sort in descending order.

>>> horses
[[18, 14, 22, 13, 7], [6, 12, 21, 15, 25], [20, 24, 19, 17, 2], [10, 16, 9, 11, 5], [4, 3, 23, 1, 8]]
>>> len(horses)
5
>>> horses
[[18, 14, 22, 13, 7], [6, 12, 21, 15, 25], [20, 24, 19, 17, 2], [10, 16, 9, 11, 5], [4, 3, 23, 1, 8]]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> horses
[[7, 13, 14, 18, 22], [6, 12, 15, 21, 25], [2, 17, 19, 20, 24], [5, 9, 10, 11, 16], [1, 3, 4, 8, 23]]
>>> for race in horses:
	print(race)

	
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[22, 18, 14, 13, 7]
[25, 21, 15, 12, 6]
[24, 20, 19, 17, 2]
[16, 11, 10, 9, 5]
[23, 8, 4, 3, 1]
>>> help(sorted)
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.
    
    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.

>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
>>> last
<function last at 0x039CEF58>
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]

[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
>>> help(sorted)
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.
    
    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.

>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]

[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]

[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[1, 3, 4, 8, 23]
[7, 13, 14, 18, 22]
[5, 9, 10, 11, 16]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]

[5, 9, 10, 11, 16]
[7, 13, 14, 18, 22]
[1, 3, 4, 8, 23]
[2, 17, 19, 20, 24]
[6, 12, 15, 21, 25]
>>> 
= RESTART: C:\Users\samue\AppData\Local\Programs\Python\Python38-32\Free Code Camp.py
[7, 13, 14, 18, 22]
[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[5, 9, 10, 11, 16]
[1, 3, 4, 8, 23]

[6, 12, 15, 21, 25]
[2, 17, 19, 20, 24]
[1, 3, 4, 8, 23]
[7, 13, 14, 18, 22]
[5, 9, 10, 11, 16]
>>> new_horses
[[6, 12, 15, 21, 25], [2, 17, 19, 20, 24], [1, 3, 4, 8, 23], [7, 13, 14, 18, 22], [5, 9, 10, 11, 16]]
>>> new_horse[2:]
Traceback (most recent call last):
  File "<pyshell#108>", line 1, in <module>
    new_horse[2:]
NameError: name 'new_horse' is not defined
>>> new_horses[2:]
[[1, 3, 4, 8, 23], [7, 13, 14, 18, 22], [5, 9, 10, 11, 16]]
>>> new_horse[0][2:]
Traceback (most recent call last):
  File "<pyshell#110>", line 1, in <module>
    new_horse[0][2:]
NameError: name 'new_horse' is not defined
>>> new_horses[0][2:]
[15, 21, 25]
>>> new_horses[1][3:]
[20, 24]
>>> new_horses[2][-1]
23
>>> 